# 多功能网络与视频流工具箱

## 项目概述

本项目是一个基于 Python 和 Tkinter 的多功能桌面工具箱，集成了 RTSP 视频流压测、批量截图和网络 Ping 检测三大核心功能。它通过多线程并发处理技术，实现了高效、稳定的任务执行，同时提供了直观的图形用户界面（GUI），方便用户进行操作。

## 核心功能
 
### 1. 视频流压测 (`index.py`)

- **并发连接**：支持同时对多个 RTSP 视频流地址进行持续连接和监控。
- **状态监控**：实时显示每个视频流的连接状态、帧率（FPS）、重连次数和错误信息。
- **自动重连**：当连接断开时，采用阶梯式（1s, 5s, 10s...）延迟自动重试，避免因网络波动而频繁重连。
- **日志记录**：将所有连接日志和状态变化记录到本地文件，方便事后分析。

### 2. 批量截图 (`jietu.py`)

- **多任务并发**：支持批量输入多个 RTSP 地址，并利用多线程并行执行截图任务。
- **优化截图逻辑**：针对网络视频流不稳定的特点，在连接成功后会尝试读取多帧数据，并选择最完整的一帧进行保存，有效解决了“花屏”或“黑屏”截图问题。
- **可自定义**：支持自定义截图质量（JPEG）。
- **实时日志**：在 GUI 界面实时显示每个地址的截图成功或失败状态。

### 3. Ping 丢包检测 (`ping.py`)

- **多目标并发 Ping**：支持同时对多个 IP 地址或域名进行持续 Ping 检测。
- **实时显示**：在独立的标签页中实时展示每个目标的 Ping 结果和丢包率。
- **非阻塞式 I/O**：使用跨平台（Linux/Windows）的非阻塞式 I/O 检查机制，确保在等待 Ping 结果时，GUI 界面不会卡死。
- **安全停止**：提供健壮的停止逻辑，通过单独的线程来处理进程终止和线程回收，避免了因 `thread.join()` 阻塞导致的主界面无响应问题。

---

## 依赖库与文件结构

### 依赖库

本项目需要安装以下 Python 库：

- **tkinter**: Python 标准库，用于构建 GUI 界面。
- **OpenCV**: `opencv-python`，用于 RTSP 视频流的连接、处理和截图。
- **NumPy**: `numpy`，作为 OpenCV 的依赖库，用于处理图像数据。
- **Pywin32**: `pywin32`，**仅在 Windows 系统上需要**，用于实现 Ping 工具中的非阻塞式 I/O。

### 文件结构

- `main.py`: 项目主入口文件，负责创建主窗口和标签页，并加载其他功能模块。
- `ping.py`: Ping 工具的核心实现，包含 Ping 任务的并发处理和日志记录逻辑。
- `index.py`: 视频流压测工具的核心实现，包含 RTSP 流的监控、重连和日志处理逻辑。
- `jietu.py`: 批量截图工具的核心实现，包含 RTSP 截图任务的并发和优化逻辑。
- `ping_log/`: 运行 Ping 工具后自动创建，用于存放 Ping 日志。
- `LOG/`: 运行视频流压测后自动创建，用于存放 RTSP 压测日志。
- `IMG/`: 运行批量截图后自动创建，用于存放截图文件。

---

## 核心实现原理

### 1. 模块化与 GUI 架构

- `main.py` 采用 `tkinter.ttk.Notebook` 组件，将不同功能的 `Frame`（`PingToolFrame`、`StressTestFrame` 等）作为独立的标签页，实现了清晰的模块化结构。
- 每个功能模块（如 `ping.py`）都是一个独立的类，负责自身的 UI 布局和业务逻辑，与主程序解耦。

### 2. 多线程并发

- 所有耗时操作（如网络连接、视频流读取、Ping 检测）都被放在单独的子线程中执行。
- `ping.py` 和 `index.py` 都为每个任务（每个 IP 或 RTSP 地址）创建一个独立的线程，实现了真正的并发。
- 使用 `threading.Event` 对象作为停止信号，当主线程需要停止任务时，只需设置此事件，子线程便能及时响应并退出。

### 3. 非阻塞式 I/O 与 GUI 响应

- `ping.py` 中，`ping_worker` 线程通过 `subprocess.Popen` 启动 Ping 进程，并从其标准输出管道中读取数据。
- 为了避免 `readline()` 方法在没有输出时阻塞线程，程序在 Windows 上使用 `win32pipe.PeekNamedPipe`，在 Linux/macOS 上使用 `select.select` 来预先判断管道中是否有可读数据。这种**非阻塞式 I/O**是确保 GUI 响应的关键。
- 子线程通过 `self.after(0, ...)` 方法将日志更新和状态变化等任务安全地传递回主 GUI 线程，避免了线程间直接操作 UI 控件而引发的错误。

### 4. 健壮的停止与退出机制

- `ping.py` 和 `index.py` 的 `stop_ping()` 和 `stop_monitoring()` 方法都采用了以下安全退出策略：
    1. 设置所有子线程的停止事件。
    2. 启动一个单独的“关闭”线程（如 `_shutdown_worker`），由其负责等待所有子线程结束。
    3. 在这个“关闭”线程中，会主动尝试强制终止子进程（通过 `taskkill` 或 `os.kill`），以防子线程因阻塞而无法退出。
- 这种机制将阻塞操作从主线程中剥离，从根本上解决了点击停止按钮时界面卡死的问题。

---

## 安装与部署

### 1. 环境准备

确保您的计算机上已安装 Python 3.6 或更高版本。

### 2. 下载项目

从 GitHub 或其他来源下载本项目的全部文件，并将它们放在同一个文件夹内。

### 3. 安装依赖

打开终端或命令提示符，进入项目根目录，然后运行以下命令来安装所有必需的库：

```bash
pip install opencv-python numpy
```

如果您在 **Windows** 系统上运行，还需要额外安装 `pywin32`：

Bash

`pip install pywin32`

### 4. 运行程序

依赖库安装完毕后，直接运行主程序文件即可：

Bash

`python main.py`

### 5. 打包成可执行文件（可选）

如果您希望将程序打包成单个可执行文件，可以安装 `pyinstaller`：

Bash

`pip install pyinstaller`

然后，使用以下命令进行打包。`--onefile` 表示打包成单个文件，`--noconsole` 表示运行时不显示命令行窗口。
**注意：`pyinstaller` 会自动检测并使用系统中已安装的 UPX 工具进行压缩。**

Bash

`pyinstaller --onefile --noconsole main.py`